# HMH_STUDY
## 2023.7.13
complete git config on docker-ubuntu, successfully access to remote git repository 11:08
learning to read assambly code
## 2023.7.17
完成linux中elf格式和x86汇编和指令集的学习
学会IDA和gdb的基本使用
## 2023.7.18
* `.text节、.data节等是什么意思?`

    .text节 elf文件中的程序代码所在的节，可读可执行但不可写
    .data节 elf文件中已初始化的程序全局变量或静态变量所在的节，可读写
* `在一个典型的C/C++程序中，全局变量、栈变量、堆变量，在汇编语言层面是如何体现的?`

    * 全局变量：已初始化的存放在.data，未初始化的存放在.bss，在代码段被使用。
    * 堆变量：调用system call在程序内存的堆上分配空间，参数为需要分配的字节数(编译器自行计算)。且必须销毁！(也是系统调用)
    
        *注意：int* ptr = new int[5];中的ptr是局部变量，栈变量，new出来的数组才是放在堆里的。
    * 栈变量：程序中的局部变量或部分函数参数，存放在栈中。每个函数都自己的帧，由栈底指针确定当前栈。以小端系统为例，栈顶指针增回收栈，减扩容栈，push压栈并减，pop弹栈并增。一般通过栈底指针加偏移量取值(栈底指针较稳定)。在x86-64中栈底指针通常存放在rbp，栈顶指针存放在rsp。(risc-v的fp,sp)。
* `ELF程序的节的权限是什么意思，例如，什么是可读、可写、可执行等?`
    
    节的权限是指在程序运行时对节的操作权限。
    
    可读，通常的elf所有节都是可读的，但也可以手动更改设为不可读。
    可写，如.bss节, .data节，可以对节的内容进行修改
    可执行，如.text节(程序的代码段)。
* `ELF程序中，符号是什么意思，调试信息是什么意思，字符串、符号、调试信息有什么区别?`

    * 符号（Symbols）是与程序中的函数、变量或其他实体相关联的标识符。
        * 有三种类型（c/c++为例）:
            * global symbol 没被static修饰的全局变量，外部文件可引用
            * external symbol 引用的定义在别的文件中的global symbol
            * local symbol 被static修饰的全局变量，只在本文件中可被引用

        * 强弱之分：已初始化的为强符号，反之为弱。对符号引用和符号定义连接的过程会有影响：
            * 不能有同名的强符号，会error
            * 同名的强符号和弱符号，linker选强符号
            * 同名的弱符号，linker随机选择一个  

    * 调试信息是是与程序执行相关的附加数据，用于在调试和分析程序时提供更多的上下文和信息。调试信息包含有关源代码文件、行号、变量名称、类型信息和编译器生成的其他调试相关信息。这些信息有助于调试器和其他工具在源代码级别进行调试和分析。gcc/g++中带参数-g生成可调试的可执行文件.out
    * 字符串是一种数据类型，用于存储文本数据，通常用于表示符号名称、文件路径和调试信息中的文本

* `x86-64寄存器`

    常用的有：
    * `rax` 常用作函数返回值
    * `rsp`栈顶指针
    * `rbp` 栈底指针
    * `rdi,rsi,rdx,rcx` 常用作入参数
    * `rip` 指令指针寄存器
    * `r8~r15` 通用寄存器
    * `CF` 进位标志寄存器
    * `ZF` 零标志寄存器
    * `PF` 奇偶标志寄存器

    </br>
* `常见寻址模式在汇编语言中的表现形式`
    * 直接寻址 `mov rax, QWORD PTR [0x007]`
    * 立即数寻址 `mov rdi,0x0`
    * 寄存器寻址 `mov rdi,rax`
    * 寄存器相对寻址 `mov DWORD PTR [rbp-0x14],edi`
    
    </br>
* `条件跳转、非条件跳转、间接跳转、函数调用、返回`
    * 条件跳转 检查零标识位寄存器ZF(通过cmp指令设定)
    </br>JE/JZ：如果上一次比较结果为相等，则跳转到目标地址。
    </br>JNE/JNZ：如果上一次比较结果为不相等，则跳转到目标地址。
    </br>JG/JNLE：如果上一次比较结果为大于，则跳转到目标地址。
    </br>JGE/JNL：如果上一次比较结果为大于等于，则跳转到目标地址。
    </br>JL/JNGE：如果上一次比较结果为小于，则跳转到目标地址。
    </br>JLE/JNG 如果上一次比较结果为小于等于，则跳转到目标地址。
    * 非条件跳转
    </br>JMP 直接跳转到目标地址位置
    * 间接跳转 常见于调用其他模块的函数，如使用标准c库的printf()。先跳转plt，在从got中找到并跳转该函数第一条指令的实际内存地址处。
    * 函数调用
    </br>call 跳转并将rip的值（即下一条指令的地址）压栈
    * 返回 
    </br> ret 从栈中弹出返回地址并跳转，同时恢复栈底指针rbp到上一函数帧的栈底。
* `什么是PIE、PIC?`
</br> PIE(Position-Independent Executable) 位置无关代码所组成的可执行二进制文件，有时可称为PIC Executable。当程序加载时，PIE文件以及它所有的依赖都会加载到虚拟内存空间中的随机位置
</br>PIC(Position-Independent Code)位置无关代码。典型的如对共享库的调用。通过plt,got进行跳转,指令中没有实际的函数地址，在运行时由动态链接器确定并写入.got
* `string instruction`
</br>专用于字符串操作的指令，有cmps,movs,lods,stos等
* `函数调用时的参数传递方案（即AMD64 Calling Convention）`
    1. 入参 调用前需要为被调函数准备好参数
        * 根据需要取用rcx,rdx,r8,r9寄存器。首先将寄存器中的原本的值压栈，再将参数的值给寄存器。
        * 若入参个数大于四，则从第五个入参开始都存在栈里，则存放于栈中。
    2. call 指令调用被调函数，同时将返回地址（即下一条指令的地址）压栈。
    3. 被调函数 
        * 将主调函数的rbp压栈，然后修改rbp使其指向被调函数帧的栈底（mov rbp,rsp）
        * 通过寄存器和栈底指针rbp+偏移取入参。
    4. 返回 
        * ret 从栈中弹出返回地址并跳转，同时恢复栈底指针rbp到上一函数帧的栈底。
        * 清理栈中的参数。
        * 从栈中恢复rcx,rdx,r8,r9寄存器（若使用）