# `CRASH pwn02`

## SOLUTION
该题同样是一个栈溢出漏洞
反编译如下
```c
int sub_80488F0()
{
...
sub_804F8B0("Welcome to my encrypt server");
  for ( i = v6; ; ++i )
  {
    if ( (int)sub_806DBE0(0, i, 1) <= 0 )   //取输入值，放在栈中
    {
      sub_804F8B0("read error");
      sub_804E4E0(-1);
    }
    v3 = off_80EB068[v0 & 7];
    v4 = v3 == *i;
    *i ^= v3;
    if ( v4 )
      break;
    v1 = 0;
LABEL_3:
    ++v0;
  }
  if ( ++v1 != 8 )
    goto LABEL_3;
  sub_804F8B0("The plaintext is:");
  return sub_804F8B0(v6);
}
```
### `覆盖返回地址`
可以从该程序的反编译看出该程序并没有对输入的大小进行限制，只要输入的字符足够多，可以很容易覆盖掉返回地址。
### `返回`
难点主要在于使该函数执行返回，即使`[v4==0]`。
</br>可以看出跳出循环执行返回的条件是

1. *i(即输入的字符)与v3(全局字符数组变量off_80EB068在[v0&7]处的值)
2. v1=8

即输入的最后8位字符应等于全局字符数组变量off_80EB068从[v0&7]处起的8个字符。
而由于：</br>
* v0表示输入的是第几个字符，已知。
* 检查edx寄存器即知全局数组变量在内存中的地址
```
mov     edx, off_80EB068
```
</br>即off_80EB068从[v0&7]中全为已知量，只需检查内存即可得知我们需要的8个字符，将其作为最后输入的8个字符，即可实现返回
综上，覆盖返回地址再让函数执行返回即可触发崩溃。

### `总结`

先看懂程序在干什么，然后从自己和程序进行交互的地方入手。